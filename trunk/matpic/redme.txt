red me

this is about C version of matpic, lua file is older test implementation
to build, either copy Makefile.watcom to Makefile and run "wmake" if you are using openwatcom
or on linux/unix copy or link Makefile.nix to Makefile and run "make"
currently only 14bit PIC chips are supported
synopsis
	matpic [-d|p|P|t] [<infile> [<outfile>]]
options
	-d	disassemble
	-p	only preprocess
	-P	don't preprocess
	-t	after assembling instead of giving ihex output, disassemble again
when no files specified input file is read from stdin, output written to stdout
comments can be started with ";", they end together with the line
multiline or part-of line comments can be started with "/*" and ended with "*/", they can also be nested
or u c be creative and use "if 0" & "endif"
if there is a backslash ("\") before a newline, the newline will be ignored
+ - * / % & | ^ << >> ~ ! == != > < >= <= () behave as in C,
 except that &, ^ and | have higher precedence than the comparison operators (<, >, <=, >=, ==, !=)
$ is the address at start of line
expressions between square braclets (i.e. [1+2]) are evaluated in the preprocessor
identifiers can be described by regex as /[a-zA-Z_][a-zA-Z0-9]*/
lines are divided as follows:
	[<label>] [<instruction> [<argument>, <...>]]
if an identifier is neither a directive or instruction and present before any whitespace, it's considered a label
if an identifier is followed by a (and before any instruction/directive) ':' it's considered a label
if a label starts with a '.' it's considered a local label (it can also be given a : at the end)
more dots before a local label make it local to a local label and so on
you can call a local label out of its scope like label.locallabel
following directives exist:
	org <origin>: set origin
	data <value>, <value>: put stray words into bytecode
	file "<filename>": tell assembler what file it is working on (also sets next line # to 1)
	line <line #>: tell assembler what the next line is numbered
	nocount: stop counting lines until next file or line directive
also there is preprocessor directives (these do not allow a label on the same line):
	define, if, ifdef, ifndef, else, endif: behave mostly like C
		with exception of the use of arguments in macros, in a case like
			define macro(a, b) (a + b)
		passing extra arguments after b, will add those to b, including commas
		define name can be put in <> bracelets to make it be preprocessed
	xdefine, undef and rep do what they does in nasm, with rep you get '@@' to tell you what iteration is current
	msg "<message>": show a message
	warning "<message>": show a threatning message
	error "<message>": show a deadly message
	they don't need # like in C (though it is allowed, you even can use % like in nasm)
special case of preprocessor is multiline macro, synopsis:
	macro <identifier> [<argument name>, <...>]
they are ended with:
	endm
nesting of multiline macros r supported
in multiline macros '@0' or just '@' denotes the number of arguments excluding named ones
@1 @2 etc are the actual arguments
expressions can be used to select the argument if you place it in bracelets like '@(<expression>)'
also those expressions can be preprocessed if you use [] bracelets
macro arguments won't be expanded in macros expanded inside the macro
integer notation supports the following prefixes:
	none at all: decimal
	0d, 0t: decimal
	$, 0x, 0h: hexadecimal
	0b, 0y: binary
	0o, 0q: octal
	0: octal
and the following suffixes:
	d, t: decimal
	x, h: hex
	b, y: binary
	o, q: octal
b and d suffix and 0b and 0d suffix are ignored if the default radix is hex
underscores within integers are ignored (but not in prefix plz)
utf-8 in labels / macro names etc are allowed
